---
title: "Работа с map в Go"
description: "Краткое руководство по работе с типом map (ассоциативный массив) в Go. Узнайте, как объявлять, инициализировать, добавлять, удалять элементы, безопасно работать в многопоточных программах и использовать продвинутые паттерны."
tags: [
  "Go",
  "Golang",
  "map",
  "ассоциативный массив",
  "хэш-таблица",
  "структуры данных",
  "ключ-значение",
  "типы данных",
  "многопоточность",
  "конкурентность",
  "sync.RWMutex",
  "итерация",
  "нулевое значение",
  "сравнимый тип"
]
keywords: [
  # Высокочастотные запросы (ядро темы)
  "map в Go",
  "карта Golang",
  "ассоциативный массив Go",
  "хэш-таблица Golang",
  "тип map Go",
  "работа с map",

  # Запросы по использованию и синтаксису
  "как создать map в Go",
  "добавление элемента map golang",
  "удаление элемента map delete",
  "проверка ключа в map ok",
  "цикл for range по map",
  "литерал map Go",
  "длина map len",

  # Запросы, связанные с особенностями и лучшими практиками
  "нулевое значение map",
  "nil map паника",
  "make map golang",
  "ключи map сравниваемые типы",
  "структура как ключ map",
  "map в map вложенная",
  "порядок итерации map",
  "сортировка ключей map",

  # Запросы по конкурентности (важная подтема)
  "map не безопасна для конкурентности",
  "синхронизация map golang",
  "sync.RWMutex map",
  "конкурентный доступ к map",
  "гонка данных map",

  # Решение конкретных задач (длинный хвост)
  "пример использования map как множества",
  "map со срезами в качестве значений",
  "подсчет частоты элементов map",
  "как обойти map в порядке ключей",
  "обнаружение циклов в списке с помощью map",
  "группировка данных с помощью map"
]
categories: ["Docs"]
date: 2025-11-30
draft: false
weight: 1
originalUrl: "https://go.dev/blog/maps"
---

Эндрю Герранд  
6 февраля 2013

### Введение
Одной из наиболее полезных структур данных в информатике является **хэш-таблица**. Существует множество реализаций хэш-таблиц с различными свойствами, но в целом они обеспечивают быстрый поиск, добавление и удаление элементов. В Go предоставляется встроенный тип `map`, который реализует хэш-таблицу.

### Объявление и инициализация
Тип map в Go выглядит так:

```go
map[KeyType]ValueType
```

где `KeyType` может быть любым **сравниваемым** типом (об этом позже), а `ValueType` — любым типом, включая другой map!

Переменная `m` ниже представляет собой map с ключами типа `string` и значениями типа `int`:

```go
var m map[string]int
```

Типы map являются **ссылочными типами**, как указатели или срезы, поэтому значение `m` выше равно `nil` — оно не ссылается на инициализированную map. При чтении `nil` map ведёт себя как пустая map, но попытка записи в `nil` map вызовет панику времени выполнения (**runtime panic**). Так делать не стоит. Для инициализации map используйте встроенную функцию `make`:

```go
m = make(map[string]int)
```

Функция `make` выделяет память и инициализирует структуру данных хэш-таблицы, возвращая значение map, которое указывает на неё. Детали реализации этой структуры данных зависят от рантайма и не специфицированы самим языком. В этой статье мы сосредоточимся на **использовании** map, а не на их внутреннем устройстве.

### Работа с map
Go предоставляет привычный синтаксис для работы с map. Этот оператор устанавливает ключу `"route"` значение `66`:

```go
m["route"] = 66
```

Этот оператор извлекает значение, хранящееся по ключу `"route"`, и присваивает его новой переменной `i`:

```go
i := m["route"]
```

Если запрашиваемый ключ не существует, мы получаем **нулевое значение** для типа значения (`ValueType`). В данном случае тип значения — `int`, поэтому нулевое значение равно `0`:

```go
j := m["root"]
// j == 0
```

Встроенная функция `len` возвращает количество элементов в map:

```go
n := len(m)
```

Встроенная функция `delete` удаляет запись из map:

```go
delete(m, "route")
```

Функция `delete` ничего не возвращает и не делает ничего, если указанный ключ не существует.

Присваивание с **двумя значениями** проверяет наличие ключа:

```go
i, ok := m["route"]
```

В этом операторе первое значение (`i`) получает значение, хранящееся по ключу `"route"`. Если ключ не существует, `i` будет нулевым значением для типа значения (`0`). Второе значение (`ok`) имеет тип `bool` и равно `true`, если ключ присутствует в map, и `false` — если отсутствует.

Чтобы проверить наличие ключа без получения значения, используйте подчёркивание (`_`) вместо первого значения:

```go
_, ok := m["route"]
```

Для перебора содержимого map используйте ключевое слово `range`:

```go
for key, value := range m {
    fmt.Println("Key:", key, "Value:", value)
}
```

Для инициализации map с данными используйте **литерал map**:

```go
commits := map[string]int{
    "rsc": 3711,
    "r":   2138,
    "gri": 1908,
    "adg": 912,
}
```

Тот же синтаксис можно использовать для инициализации пустой map, что функционально идентично использованию функции `make`:

```go
m = map[string]int{}
```

### Использование нулевых значений
Бывает удобно, что при отсутствии ключа операция получения значения из map возвращает нулевое значение.

Например, map с булевыми значениями можно использовать как **структуру данных типа "множество"** (напомним, что нулевое значение для типа `bool` — `false`). В следующем примере выполняется обход связного списка узлов (`Node`) и вывод их значений. Используется map указателей на `Node` для обнаружения циклов в списке.

```go
type Node struct {
    Next  *Node
    Value interface{}
}
var first *Node

visited := make(map[*Node]bool)
for n := first; n != nil; n = n.Next {
    if visited[n] {
        fmt.Println("cycle detected")
        break
    }
    visited[n] = true
    fmt.Println(n.Value)
}
```

Выражение `visited[n]` равно `true`, если узел `n` уже был посещён, или `false`, если `n` отсутствует в map. Нет необходимости использовать форму с двумя значениями для проверки наличия `n` в map — нулевое значение по умолчанию делает это за нас.

Другой пример полезности нулевых значений — map со **срезами** в качестве значений. Добавление элемента в `nil` срез просто выделяет новый срез, поэтому добавление значения в map срезов можно выполнить одной строкой; не нужно проверять существование ключа. В следующем примере срез `people` заполняется значениями типа `Person`. Каждый `Person` имеет поле `Name` и срез `Likes`. Пример создаёт map для связи каждого предпочтения (`like`) со срезом людей, которым оно нравится.

```go
type Person struct {
    Name  string
    Likes []string
}
var people []*Person

likes := make(map[string][]*Person)
for _, p := range people {
    for _, l := range p.Likes {
        likes[l] = append(likes[l], p)
    }
}
```

Чтобы вывести список людей, которые любят сыр:

```go
for _, p := range likes["cheese"] {
    fmt.Println(p.Name, "likes cheese.")
}
```

Чтобы вывести количество людей, которые любят бекон:

```go
fmt.Println(len(likes["bacon"]), "people like bacon.")
```

Заметим, что поскольку `range` и `len` трактуют `nil` срез как срез нулевой длины, эти два последних примера будут работать, даже если никто не любит сыр или бекон (как бы маловероятно это ни было).

### Типы ключей
Как упоминалось ранее, ключами map могут быть любые **сравниваемые типы**. Спецификация языка определяет это точно, но коротко: сравниваемыми типами являются логические, числовые, строковые типы, указатели, каналы, интерфейсы, а также структуры или массивы, содержащие только эти типы. Важно отметить, что **срезы, map и функции** отсутствуют в этом списке; эти типы нельзя сравнивать с помощью `==`, и они **не могут быть ключами map**.

Очевидно, что строки, целые числа и другие базовые типы могут быть ключами map, но, возможно, неожиданными кажутся ключи-структуры. Структуры позволяют организовать данные по **нескольким измерениям**. Например, эта map map'ов может использоваться для подсчёта посещений веб-страниц по странам:

```go
hits := make(map[string]map[string]int)
```

Это map типа `string` -> (`map[string]int`). Каждый ключ внешней map — это путь к веб-странице, имеющей свою внутреннюю map. Каждый ключ внутренней map — это двухбуквенный код страны. Это выражение получает количество загрузок страницы документации пользователями из Австралии:

```go
n := hits["/doc/"]["au"]
```

К сожалению, этот подход становится громоздким при добавлении данных, так как для любого заданного внешнего ключа нужно проверять существование внутренней map и создавать её при необходимости:

```go
func add(m map[string]map[string]int, path, country string) {
    mm, ok := m[path]
    if !ok {
        mm = make(map[string]int)
        m[path] = mm
    }
    mm[country]++
}
add(hits, "/doc/", "au")
```

С другой стороны, дизайн с использованием **одной map и ключа-структуры** устраняет всю эту сложность:

```go
type Key struct {
    Path, Country string
}
hits := make(map[Key]int)
```

Когда человек из Вьетнама посещает главную страницу, инкрементировать (и, возможно, создать) соответствующий счётчик — это одна строка:

```go
hits[Key{"/", "vn"}]++
```

И так же просто узнать, сколько людей из Швейцарии прочитали спецификацию:

```go
n := hits[Key{"/ref/spec", "ch"}]
```

### Конкурентность
Map **не безопасны для конкурентного использования**: не определено, что произойдёт при одновременном чтении и записи. Если вам нужно читать из map и писать в неё из параллельно выполняющихся горутин, доступ должен быть защищён каким-либо механизмом синхронизации. Один из распространённых способов защиты map — использование `sync.RWMutex`.

Этот оператор объявляет переменную-счётчик, которая является анонимной структурой, содержащей map и встроенный `sync.RWMutex`:

```go
var counter = struct{
    sync.RWMutex
    m map[string]int
}{m: make(map[string]int)}
```

Для чтения из счётчика возьмите **блокировку на чтение**:

```go
counter.RLock()
n := counter.m["some_key"]
counter.RUnlock()
fmt.Println("some_key:", n)
```

Для записи в счётчик возьмите **блокировку на запись**:

```go
counter.Lock()
counter.m["some_key"]++
counter.Unlock()
```

### Порядок итерации
При итерации по map с помощью цикла `range` **порядок итерации не определён** и не гарантируется одинаковым от одной итерации к другой. Если требуется **стабильный порядок итерации**, необходимо поддерживать отдельную структуру данных, которая задаёт этот порядок. В этом примере используется отдельный отсортированный срез ключей для вывода map `map[int]string` в порядке ключей:

```go
import "sort"

var m map[int]string
var keys []int
for k := range m {
    keys = append(keys, k)
}
sort.Ints(keys)
for _, k := range keys {
    fmt.Println("Key:", k, "Value:", m[k])
}
```