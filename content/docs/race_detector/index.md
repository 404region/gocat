---
title: "Детектор гонок данных (Data Race Detector)"
description: ""
tags: [
  "Go",
  "Golang",
  "Детектор гонок",
  "Data Race",
  "Многопоточность",
  "Concurrency",
  "Отладка",
  "go test -race",
  "GORACE",
  "Модель памяти Go",
  "Горутины",
  "Синхронизация",
  "sync.Mutex",
  "sync/atomic",
  "Тестирование",
  "Производительность",
  "Безопасность памяти"
]
keywords: [
  # Основные высокочастотные запросы
  "гонка данных Go",
  "data race golang",
  "детектор гонок данных",
  "go race detector",
  "флаг -race",
  "как найти data race",
  "отладка многопоточных программ golang",

  # Запросы, связанные с использованием и настройкой
  "go test -race пример",
  "GORACE опции",
  "log_path strip_path_prefix",
  "детектор гонок отчет",
  "формат отчета data race",
  "исключение тестов race detector",
  "тег сборки race",

  # Типичные проблемы и паттерны (очень важны для длинного хвоста)
  "гонка на счетчике цикла Go",
  "неявно общая переменная горутина",
  "незащищенная глобальная переменная race",
  "гонка примитивных типов int bool",
  "несинхронизированные операции с каналом send close",
  "примеры гонок данных в Golang",
  "типичные ошибки многопоточности Go",

  # Решения и best practices
  "как исправить data race",
  "sync.Mutex защита от гонок",
  "atomic операции Go",
  "правильная синхронизация каналов",
  "пакет sync/atomic пример",

  # Теория и объяснения
  "что такое гонка данных",
  "модель памяти Go happens before",
  "накладные расходы детектора гонок",
  "требования race detector windows linux",
  "как работает детектор гонок"
]
categories: ["Docs"]
date: 2025-11-30
draft: false
weight: 1
originalUrl: "https://go.dev/doc/articles/race_detector"
---

## Введение

Гонки данных (data races) являются одним из самых распространенных и сложных для отладки типов ошибок в параллельных системах. Гонка данных возникает, когда две горутины обращаются к одной и той же переменной одновременно, и по крайней мере одно из обращений является записью. Подробности см. в [Модель памяти Go](https://golang.org/ref/mem).

Вот пример гонки данных, которая может приводить к сбоям и повреждению памяти:

```go
func main() {
    c := make(chan bool)
    m := make(map[string]string)
    go func() {
        m["1"] = "a" // Первое конфликтующее обращение
        c <- true
    }()
    m["2"] = "b" // Второе конфликтующее обращение
    <-c
    for k, v := range m {
        fmt.Println(k, v)
    }
}
```

## Использование

Для диагностики таких ошибок Go включает встроенный детектор гонок данных. Чтобы использовать его, добавьте флаг `-race` к команде go:

```bash
$ go test -race mypkg    # для тестирования пакета
$ go run -race mysrc.go  # для запуска исходного файла
$ go build -race mycmd   # для сборки команды
$ go install -race mypkg # для установки пакета
```

## Формат отчета

Когда детектор гонок обнаруживает гонку данных в программе, он выводит отчет. Отчет содержит стектрейсы стека для конфликтующих обращений, а также стеки создания задействованных горутин. Вот пример:

```
WARNING: DATA RACE
Read by goroutine 185:
  net.(*pollServer).AddFD()
      src/net/fd_unix.go:89 +0x398
  net.(*pollServer).WaitWrite()
      src/net/fd_unix.go:247 +0x45
  net.(*netFD).Write()
      src/net/fd_unix.go:540 +0x4d4
  net.(*conn).Write()
      src/net/net.go:129 +0x101
  net.func·060()
      src/net/timeout_test.go:603 +0xaf

Previous write by goroutine 184:
  net.setWriteDeadline()
      src/net/sockopt_posix.go:135 +0xdf
  net.setDeadline()
      src/net/sockopt_posix.go:144 +0x9c
  net.(*conn).SetDeadline()
      src/net/net.go:161 +0xe3
  net.func·061()
      src/net/timeout_test.go:616 +0x3ed

Goroutine 185 (running) created at:
  net.func·061()
      src/net/timeout_test.go:609 +0x288

Goroutine 184 (running) created at:
  net.TestProlongTimeout()
      src/net/timeout_test.go:618 +0x298
  testing.tRunner()
      src/testing/testing.go:301 +0xe8
```

## Опции

Переменная окружения `GORACE` устанавливает опции детектора гонок. Формат:

```
GORACE="option1=val1 option2=val2"
```

Доступные опции:

- `log_path` (по умолчанию stderr - стандартный поток ошибок): Детектор гонок записывает отчет в файл с именем `log_path.pid`. Специальные имена `stdout` и `stderr` приводят к записи отчетов в стандартный вывод и стандартный вывод ошибок соответственно.
- `exitcode` (по умолчанию 66): Код завершения при выходе после обнаруженной гонки.
- `strip_path_prefix` (по умолчанию ""): Удаляет этот префикс из всех reported file paths, чтобы сделать отчеты более краткими.
- `history_size` (по умолчанию 1): История обращений к памяти для каждой горутины составляет 32K * 2**history_size элементов. Увеличение этого значения позволяет избежать ошибки "failed to restore the stack" в отчетах ценой увеличения использования памяти.
- `halt_on_error` (по умолчанию 0): Определяет, должна ли программа завершать работу после сообщения о первой гонке данных.
- `atexit_sleep_ms` (по умолчанию 1000): Количество миллисекунд для ожидания в основной горутине перед выходом.

Пример:

```bash
$ GORACE="log_path=/tmp/race/report strip_path_prefix=/my/go/sources/" go test -race
```

## Исключение тестов

При сборке с флагом `-race` команда go определяет дополнительный тег сборки `race`. Вы можете использовать этот тег для исключения некоторого кода и тестов при запуске детектора гонок. Некоторые примеры:

```go
// +build !race

package foo

// Тест содержит гонку данных. См. issue 123.
func TestFoo(t *testing.T) {
    // ...
}

// Тест не проходит под детектором гонок из-за таймаутов.
func TestBar(t *testing.T) {
    // ...
}

// Тест выполняется слишком долго под детектором гонок.
func TestBaz(t *testing.T) {
    // ...
}
```

## Как использовать

Для начала запустите ваши тесты с использованием детектора гонок (`go test -race`). Детектор гонок находит только гонки, происходящие во время выполнения, поэтому он не может найти гонки в путях выполнения кода, которые не выполняются. Если ваши тесты имеют неполное покрытие, вы можете найти больше гонок, запустив бинарный файл, собранный с `-race`, под реалистичной рабочей нагрузкой.

## Типичные гонки данных

Вот некоторые типичные гонки данных. Все они могут быть обнаружены детектором гонок.

### Гонка на счетчике цикла

```go
func main() {
    var wg sync.WaitGroup
    wg.Add(5)
    var i int
    for i = 0; i < 5; i++ {
        go func() {
            fmt.Println(i) // Не тот 'i', который вы ищете.
            wg.Done()
        }()
    }
    wg.Wait()
}
```

Переменная `i` в литерале функции - это та же самая переменная, которая используется циклом, поэтому чтение в горутине конфликтует с инкрементом цикла. (Эта программа обычно выводит `55555`, а не `01234`). Программу можно исправить, создав копию переменной:

```go
func main() {
    var wg sync.WaitGroup
    wg.Add(5)
    var i int
    for i = 0; i < 5; i++ {
        go func(j int) {
            fmt.Println(j) // Хорошо. Чтение локальной копии счетчика цикла.
            wg.Done()
        }(i)
    }
    wg.Wait()
}
```

### Неявно общая переменная

```go
// ParallelWrite записывает данные в file1 и file2, возвращает ошибки.
func ParallelWrite(data []byte) chan error {
    res := make(chan error, 2)
    f1, err := os.Create("file1")
    if err != nil {
        res <- err
    } else {
        go func() {
            // Этот err общий с основной горутиной,
            // поэтому запись конфликтует с записью ниже.
            _, err = f1.Write(data)
            res <- err
            f1.Close()
        }()
    }
    f2, err := os.Create("file2") // Вторая конфликтующая запись в err.
    if err != nil {
        res <- err
    } else {
        go func() {
            _, err = f2.Write(data)
            res <- err
            f2.Close()
        }()
    }
    return res
}
```

Исправление заключается в использовании новых переменных в горутинах (обратите внимание на использование `:=`):

```go
            ...
            _, err := f1.Write(data)
            ...
            _, err := f2.Write(data)
            ...
```

### Незащищенная глобальная переменная

Если следующий код вызывается из нескольких горутин, это приводит к гонкам на карте service. Параллельные чтения и записи одной и той же карты небезопасны:

```go
var service map[string]net.Addr

func RegisterService(name string, addr net.Addr) {
    service[name] = addr
}

func LookupService(name string) net.Addr {
    return service[name]
}
```

Чтобы сделать код безопасным, защитите обращения мьютексом:

```go
var (
    service   map[string]net.Addr
    serviceMu sync.Mutex
)

func RegisterService(name string, addr net.Addr) {
    serviceMu.Lock()
    defer serviceMu.Unlock()
    service[name] = addr
}

func LookupService(name string) net.Addr {
    serviceMu.Lock()
    defer serviceMu.Unlock()
    return service[name]
}
```

### Незащищенная переменная примитивного типа

Гонки данных могут происходить и на переменных примитивных типов (`bool`, `int`, `int64` и т.д.), как в этом примере:

```go
type Watchdog struct{ last int64 }

func (w *Watchdog) KeepAlive() {
    w.last = time.Now().UnixNano() // Первое конфликтующее обращение.
}

func (w *Watchdog) Start() {
    go func() {
        for {
            time.Sleep(time.Second)
            // Второе конфликтующее обращение.
            if w.last < time.Now().Add(-10*time.Second).UnixNano() {
                fmt.Println("No keepalives for 10 seconds. Dying.")
                os.Exit(1)
            }
        }
    }()
}
```

Даже такие "невинные" гонки данных могут приводить к сложным для отладки проблемам, вызванным неатомарностью обращений к памяти, interference с оптимизациями компилятора или проблемами переупорядочения при обращении к памяти процессора.

Типичное исправление для этой гонки - использование канала или мьютекса. Чтобы сохранить поведение без блокировок, можно также использовать пакет `sync/atomic`.

```go
type Watchdog struct{ last int64 }

func (w *Watchdog) KeepAlive() {
    atomic.StoreInt64(&w.last, time.Now().UnixNano())
}

func (w *Watchdog) Start() {
    go func() {
        for {
            time.Sleep(time.Second)
            if atomic.LoadInt64(&w.last) < time.Now().Add(-10*time.Second).UnixNano() {
                fmt.Println("No keepalives for 10 seconds. Dying.")
                os.Exit(1)
            }
        }
    }()
}
```

### Несинхронизированные операции отправки и закрытия

Как показывает этот пример, несинхронизированные операции отправки и закрытия на одном и том же канале также могут быть состоянием гонки:

```go
c := make(chan struct{}) // или буферизированный канал

// Детектор гонок не может вывести отношение happens before
// для следующих операций отправки и закрытия. Эти две операции
// несинхронизированы и происходят параллельно.
go func() { c <- struct{}{} }()
close(c)
```

Согласно модели памяти Go, отправка в канал происходит до завершения соответствующего приема из этого канала. Чтобы синхронизировать операции отправки и закрытия, используйте операцию приема, которая гарантирует, что отправка завершена до закрытия:

```go
c := make(chan struct{}) // или буферизированный канал

go func() { c <- struct{}{} }()
<-c
close(c)
```

## Требования

Детектор гонок требует, чтобы cgo был включен, а в системах, отличных от Darwin, требуется установленный компилятор C. Детектор гонок поддерживает linux/amd64, linux/ppc64le, linux/arm64, linux/s390x, linux/loong64, freebsd/amd64, netbsd/amd64, darwin/amd64, darwin/arm64 и windows/amd64.

В Windows среда выполнения детектора гонок чувствительна к версии установленного компилятора C; начиная с Go 1.21, сборка программы с `-race` требует компилятор C, включающий версию 8 или выше библиотек времени выполнения mingw-w64. Вы можете проверить свой компилятор C, вызвав его с аргументами `--print-file-name libsynchronization.a`. Более новый совместимый компилятор C выведет полный путь к этой библиотеке, тогда как старые компиляторы C просто повторят аргумент.

## Накладные расходы времени выполнения

Стоимость обнаружения гонок варьируется в зависимости от программы, но для типичной программы использование памяти может увеличиться в 5-10 раз, а время выполнения - в 2-20 раз.

Детектор гонок в настоящее время выделяет дополнительные 8 байт на каждый оператор `defer` и `recover`. Эти дополнительные выделения не освобождаются до выхода горутины. Это означает, что если у вас есть долго работающая горутина, которая периодически вызывает `defer` и `recover`, использование памяти программой может расти неограниченно. Эти выделения памяти не будут отображаться в выводе `runtime.ReadMemStats` или `runtime/pprof`.
```