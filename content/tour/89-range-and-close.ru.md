---
title: "89. Range и Close"
date: 2025-10-12
categories: ["Tour of Go"]
description: "Изучите основы синтаксиса Go: объявление переменных, типы данных, константы и приведение типов с практическими примерами"
tags: ["горутины", "каналы", "go синтаксис", "golang основы"]
keywords: "golang, go, синтаксис golang, обучение go, tour of go, close в каналах, go каналы, конкурентность в go"
author: "GoCat Team"
weight: 89
draft: false
originalUrl: "https://go.dev/tour/concurrency/4"

---

Отправитель (sender) может закрыть канал, чтобы указать, что больше значений отправляться не будет. Получатели могут проверить, был ли канал закрыт, назначив второй параметр выражению приёма:

```go
v, ok := <-ch
```
ok будет иметь значение false, если больше нет значений для получения и канал закрыт.

Цикл for i := range c постоянно получает значения из канала, пока он не будет закрыт.

Примечание: Закрывать канал должен только отправитель, но никогда получатель. Отправка в закрытый канал вызовет панику (panic).

Ещё одно примечание: Каналы не похожи на файлы; обычно их не нужно закрывать. Закрытие необходимо только тогда, когда получатель должен быть уведомлен, что больше не будет поступать значений, например, для завершения цикла range.


{{< go-playground id="example1" >}}

package main

import (
    "fmt"
)

func fibonacci(n int, c chan int) {
    x, y := 0, 1
    for i := 0; i < n; i++ {
        c <- x
        x, y = y, x+y
    }
    close(c)
}

func main() {
    c := make(chan int, 10)
    go fibonacci(cap(c), c)
    for i := range c {
        fmt.Println(i)
    }
}

{{< /go-playground >}} 